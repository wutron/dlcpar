#!/usr/bin/env python

# python libraries
import os, sys, optparse, shutil
import time
import gzip

# rasmus, compbio libraries
from rasmus import treelib, util 
from compbio import phylo  

# dlcpar libraries
import dlcpar
from dlcpar import common 
from dlcpar import reconlib
import dlcpar.ilprecon



VERSION = dlcpar.PROGRAM_VERSION_TEXT

def parse_args():
    """parse input arguments"""

    parser = optparse.OptionParser(
        usage = "usage: %prog [options] <gene tree> ...",

        version = "%prog " + VERSION,

        description =
        "%prog is a phylogenetic program for finding " +
        "a most parsimonious gene tree-species tree reconciliation " +
        "using ILP. ",

        epilog =
        "Written by Yi-Chieh Wu (yjw@cs.hmc.edu), Harvey Mudd College. " +
        "(c) 2018. Released under the terms of the GNU General Public License."
    )

    grp_io = optparse.OptionGroup(parser, "Input/Output")
    grp_io.add_option("-s", "--stree", dest="stree",
                      metavar="<species tree>",
                      help="species tree file in newick format")
    grp_io.add_option("-S", "--smap", dest="smap",
                      metavar="<species map>",
                      help="gene to species map")
    parser.add_option_group(grp_io)

    grp_ext = optparse.OptionGroup(parser, "File Extensions")
    grp_ext.add_option("-I", "--inputext", dest="inext",
                       metavar="<input file extension>",
                       default="",
                       help="input file extension (default: \"\")")
    grp_ext.add_option("-O", "--outputext", dest="outext",
                       metavar="<output file extension>",
                       default=".dlcilp",
                       help="output file extension (default: \".dlcilp\")")
    parser.add_option_group(grp_ext)

    grp_costs = optparse.OptionGroup(parser, "Costs")
    grp_costs.add_option("-D", "--dupcost", dest="dupcost",
                         metavar="<dup cost>",
                         type="float", default=1.0,
                         help="duplication cost (default: 1.0)")
    grp_costs.add_option("-L", "--losscost", dest="losscost",
                         metavar="<loss cost>",
                         type="float", default=1.0,
                         help="loss cost (default: 1.0)")
    grp_costs.add_option("-C", "--coalcost", dest="coalcost",
                         metavar="<coal cost>",
                         type="float", default=0.5,
                         help="deep coalescence cost (default: 0.5)")
    grp_costs.add_option("-K", "--coaldupcost", dest="coaldupcost",
                         metavar="<coal dup cost>",
                         type="float",
                         help="deep coalescence cost for duplication if different")
    parser.add_option_group(grp_costs)

    grp_solver = optparse.OptionGroup(parser, "Solver")
    grp_solver.add_option("-o", "--solver", dest="solver_name",
                         metavar="<solver name>",
                         type="string", default = "CBC_CMD",
                         help="solver name: options include CBC_CMD (default) and CPLEX_PY")
    parser.add_option_group(grp_solver)

    grp_misc = optparse.OptionGroup(parser, "Miscellaneous")
    grp_misc.add_option("-t", "--time_limit", dest="time_limit",
                        metavar="<time limit>",
                        type="float", default=None,
                        help="LP solver time limit in seconds")
    grp_misc.add_option("-x", "--seed", dest="seed",
                        metavar="<random seed>",
                        type="int", default=None,
                        help="random number seed")
    grp_misc.add_option("--output_format", dest="output_format",
                        choices=["dlcpar","dlcoal"], default="dlcpar",
                        metavar="[dlcpar|dlcoal]",
                        help="specify output format (default: dlcpar)")
    parser.add_option_group(grp_misc)

    grp_info = optparse.OptionGroup(parser, "Information")
    common.move_option(parser, "--version", grp_info)
    common.move_option(parser, "--help", grp_info)
    grp_info.add_option("-l", "--log", dest="log",
                        action="store_true",
                        help="set to output debugging log")
    parser.add_option_group(grp_info)

    options, treefiles = parser.parse_args()

    #=============================
    # check arguments

    # input gene tree files
    if len(treefiles) == 0:
        parser.error("must specify input file(s)")

    # required options
    if (not options.stree) or (not options.smap):
        parser.error("-s/--stree and -S/--smap required")

    # positive costs
    if options.dupcost <= 0:
        parser.error("-D/--dupcost must be positive")
    if options.losscost <= 0:
        parser.error("-L/--losscost must be positive")
    if options.coalcost <= 0:
        parser.error("-C/--coalcost must be positive")
    if options.coaldupcost is None:
        options.coaldupcost = options.coalcost
    elif options.coaldupcost <= 0:
        parser.error("-K/--coaldupcost must be positive")
    if options.solver_name != "CBC_CMD" and options.solver_name != "CPLEX_PY":
        parser.error("solver must be CBC_CMD or CPLEX_PY")

    return options, treefiles


#==========================================================
# main

def main():
    """main"""

    # parse arguments
    options, treefiles = parse_args()

    # read species tree and species map
    stree = treelib.read_tree(options.stree)
    common.check_tree(stree, options.stree)
    gene2species = phylo.read_gene2species(options.smap)

    # random seed if not specified
    if options.seed is None:
        options.seed = int(time.time() * 100) % (2^32-1)

    # process gene trees
    for treefile in treefiles:
        # general output path
        out = util.replace_ext(treefile, options.inext, options.outext)
    
        # info file
        out_info = util.open_stream(out + ".info", 'w')

        # log file
        if options.log:
            out_log = gzip.open(out + ".log.gz", 'w')
            
            #create a temp directory
            out_tmp = out + ".pulp"
            if os.path.exists(out_tmp):
                shutil.rmtree(out_tmp)
            os.mkdir(out_tmp)
        else:
            out_log = common.NullLog()
            out_tmp = None

        # command
        cmd = "%s %s" % (os.path.basename(sys.argv[0]),
                         ' '.join(map(lambda x: x if x.find(' ') == -1 else "\"%s\"" % x,
                                      sys.argv[1:])))
        out_info.write("Version:\t%s\n" % VERSION)
        out_info.write("Command:\t%s\n\n" % cmd)
        out_log.write("DLCilp version: %s\n" % VERSION)
        out_log.write("DLCilp executed with the following arguments:\n")
        
        if options.solver_name == "CBC_CMD":
            solver_name = "CBC_CMD (pulp)"
        elif options.solver_name == "CPLEX_PY":
            solver_name = "CPLEX_PY (cplex)"
        else:
            raise Exception("Unsupported solver name input: ", options.solver_name)
    
        out_info.write("Solver used:\t%s\n\n" % solver_name)
        out_log.write("Solver used: %s\n" % solver_name)
        out_log.write("%s\n\n" % cmd)

        # read and prepare coal tree
        coal_trees = list(treelib.iter_trees(treefile))

        # multiple coal trees not supported
        if len(coal_trees) > 1:
            raise Exception("unsupported: multiple coal trees per file")

        # get coal tree
        coal_tree = coal_trees[0]
        common.check_tree(coal_tree, treefile)

        # remove bootstrap and distances if they exist
        coal_tree_top = coal_tree.copy()
        for node in coal_tree_top:
            if "boot" in node.data:
                del node.data["boot"]
            node.dist = 0
        coal_tree_top.default_data.clear()

        # print random seed 
        out_log.write("Seed: %d\n\n" % options.seed)
        out_info.write("Seed: %d\n" % options.seed)

        # perform reconciliation
        return_vals = dlcpar.ilprecon.ilp_recon(coal_tree, stree, gene2species,
            dupcost=options.dupcost, losscost=options.losscost,
            coalcost=options.coalcost, coaldupcost=options.coaldupcost, 
            solver=options.solver_name, seed=options.seed, time_limit=options.time_limit, 
            delay=False, log=out_log, info_log=out_info, tmp=out_tmp)

        # write info
        gene_tree, labeled_recon, runtime, setup_runtime, solve_runtime, optimal_cost = return_vals
        
        # write outputs
        if labeled_recon:
            
            out_info.write("ILP to LCT Conversion:\t%s\n" % "passed")
            
            if options.output_format == "dlcoal":
                coal_tree, recon = reconlib.labeledrecon_to_recon(gene_tree, labeled_recon, stree)
                recon.write(out, coal_tree)
            else:
                labeled_recon.write(out, gene_tree)

            # the following are used to find the tree-events cost
            gene_tree, extra = reconlib.read_labeled_recon(out, stree)
            stree_copy = stree.copy()
            reconlib.init_dup_loss_coal_tree(stree_copy, split_coals=True)
            events_list = reconlib.count_dup_loss_coal_tree(gene_tree, extra, stree_copy, gene2species,
                                                            implied=True, split_coals=True)

            # get tree_events_cost
            ndup, nloss, ncoalspec, ncoaldup, nappear = events_list
            tree_events_cost = options.dupcost * ndup + options.losscost * nloss + options.coalcost * ncoalspec + options.coaldupcost * ncoaldup
            
            # sanity check of tree-events and ilp costs
            if tree_events_cost == optimal_cost:
                out_info.write("Cost check:\t%s\n" % "passed")
            else:
                out_info.write("Cost check:\t%s\n" % "failed")
                out_info.write("tree-events cost is: \t%f\n" % tree_events_cost) 
                
                #Write more information in .log file
                out_log.write("\ntree-events cost is: \t" + str(tree_events_cost))
                out_log.write("\n\tDups:\t" + str(ndup))
                out_log.write("\n\tLosses:\t" + str(nloss))
                out_log.write("\n\tCoalspecs:\t" + str(ncoalspec))   
                out_log.write("\n\tCoaldups:\t" + str(ncoaldup))
                out_log.write("\n\nCost check:\t" + "failed")
        else:
            out_info.write("ILP to LCT Conversion:\t%s\n" % "failed")

        out_info.write("Optimal Cost:\t%f\n" % optimal_cost)
        out_info.write("Runtime:\t%f sec\n" % runtime)
        out_info.write("Runtime (Setup):\t%f sec\n" % setup_runtime)
        out_info.write("Runtime (Solve):\t%f sec\n" % solve_runtime)

    # end log
    if options.log:
        out_log.close()

    # end info
    out_info.close()

# main function
if __name__ == "__main__":
    sys.exit(main())
